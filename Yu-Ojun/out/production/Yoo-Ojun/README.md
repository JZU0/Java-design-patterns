1. Strategy 패턴
    금융 서비스에서는 다양한 금융 알고리즘 전략이 필요하고, 실행 중에 다양한 전략을 선택해야 합니다. 투자 전략, 계산 방법 및 수익률 예측은 다양하고, 고유한 클래스로 구현되지만, 런타임에 전략을 교체해야 하는 상황이 존재합니다.
    **Strategy 패턴은 이런 요구 사항을 충족시키고, 다양한 투자 전략을 런타임에 교체할 수 있게 합니다.** 

    본 코드는 Strategy 패턴을 사용하여 투자 전략을 구현합니다.
    적극적인 투자 전략은 주가가 떨어졌을 때 미래를 생각해서 주식을 매매하고, 주가가 올랐을 때는 미래를 생각해서 주식을 매도합니다. 소극적인 투자 전략은 주가가 떨어졌을 때 매도하고, 주식이 오르면 매매합니다. (실제 투자와 관련은 없고 임의로 설정한 전략입니다)
    이러한 방식이 프로그램을 복잡하게 만드는 것처럼 보이지만 그렇지 않습니다. 만약 적극적인 투자 전략을 개량하고 싶다고 가정을 했을 때, 저는 Strategy 패턴을 사용했기 때문에 인터페이스를 수정하지 않고 적극적인 투자 전략 클래스만 수정하면됩니다.
    게다가, 위임을 해서 약한 결합으로 객체끼리 연결되어 있기 때문에 투자 전략을 용이하게 전환할 수 있습니다. 

2. State 패턴 & Singleton 패턴
   금융 서비스에서는 다양한 계좌 상태 혹은 거래 상태가 존재합니다.
   **State 패턴은 '상태'를 클래스로 표현하고 클래스를 전환함으로써 '상태 변화'를 나타낼 수 있습니다.**

   계좌 상황에 따라 계좌 상태가 교체되었다고 해도 상태는 반드시 단일된 객체이자 정보이어야 합니다. 예를 들면 아주 튼튼한 보안을 가지고 있는 상태는 반드시 하나의 인스턴스이어야 하고 이 객체에 접근해야 합니다.
   왜냐하면, 훌륭한 보안성을 갖춘 상태 정보가 새롭게 하나 더 만들어진다면 훌륭한 보안성을 유지하기 위해 객체가 가지고 있는 비용 자체가 많이 듭니다.
   또한, 상태 정보 그 자체를 가지고 있는 객체이기 때문에 다른 객체가 하나 더 생긴다면 "상태" 자체를 클래스로 표현한 의미가 옅어질 수 있습니다.

   **Singleton 패턴은 이러한 요구 사항을 충족시키며, 하나의 인스턴스만 생성하고 전역적으로 접근할 수 있도록 합니다.**

   본 코드는 State 패턴, Singleton 패턴, Map 자료 구조를 사용하고 고객 계좌의 잔액에 따라 상태를 구분합니다. 그리고, JAVA GUI를 통해 고객 계좌 상태에 따라 매도, 매매를 추천하고 경고합니다.

3. Factory 패턴
    금융 서비스에서는 여러 종류의 금융 상품을 생성해야 할 때가 있습니다.
    **Factory Method 패턴은 객체 생성을 서브 클래스에 위임하여 쉽게 확장 가능한 디자인을 제공합니다.**
    
    본 코드는 Factory 패턴을 사용하여 사용자별로 계좌를 만들고 ELS, ELW, DLS 와 같은 파생결합증권을 등록한 후에 사용하는 과정을 설명하고 있습니다.
