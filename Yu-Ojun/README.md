# README.md

## 1. Strategy 패턴

![strategy.png](README%20md%206f5078a2a2a0407b96e45c4df5174dea/strategy.png)

- 디자인 패턴 설명

금융 서비스에서는 다양한 금융 알고리즘 전략이 필요하고, 실행 중에 다양한 전략을 선택해야 합니다. 투자 전략, 계산 방법 및 수익률 예측은 다양하고, 고유한 클래스로 구현되지만, 런타임에 전략을 교체해야 하는 상황이 존재합니다.
**Strategy 패턴은 이런 요구 사항을 충족시키고, 다양한 투자 전략을 런타임에 교체할 수 있게 합니다.**

- 코드 설명

본 코드는 Strategy 패턴을 사용하여 투자 전략을 구현합니다. 10번에 걸쳐서 주가는 일정폭 안에서 랜덤으로 정해집니다. 적극적인 투자 전략은 과거의 주가와 비교하여 주가가 떨어졌을 때 미래를 생각해서 주식을 매매하고, 주가가 올랐을 때는 미래를 생각해서 주식을 매도합니다. 반대로 소극적인 투자 전략은 과거의 주가보다 주가가 떨어졌을 때 매도하고, 주식이 오르면 매매합니다. (실제 투자와 관련은 없고 임의로 설정한 전략입니다.) 실제 주가와 비슷한 형태라면 당연히 적극적인 투자 전략이 압도적으로 손해를 볼 수 밖에 없습니다. 적극적인 투자 전략은 미리 지정해둔 이익 정도를 얻으면 모두 매매하는 등의 다른 전략과 합쳐져야 어느 정도의 이익을 볼 수 있습니다. 하지만 다른 전략과 합치는 과정은 생각보다 복잡하고, Strategy 패턴을 구현하는 부분에서도 정확한 예시가 될 수 없기 때문에 적극적인 투자 방법은 손해밖에 볼 수 없는 형태로 구성하였습니다. 하지만 예외의 폭을 줄이기 위해서 주식 가격이 일정하게 변화하는 것이 아닌 랜덤으로 변화하게끔 구성하였습니다. 

- 디자인 패턴을 사용함에 따른 결과 해석

이러한 방식이 프로그램을 복잡하게 만드는 것처럼 보이지만 그렇지 않습니다. 만약 적극적인 투자 전략을 개량하고 싶다고 가정을 했을 때, 저는 Strategy 패턴을 사용했기 때문에 인터페이스를 수정하지 않고 적극적인 투자 전략 클래스만 수정하면됩니다. 게다가, 위임을 해서 약한 결합으로 객체끼리 연결되어 있기 때문에 투자 전략을 용이하게 전환할 수 있습니다. 세부 투자 전략에서는 과거의 주가와 현재의 주가를 비교해서 Trade(매도/매수를 enum으로 구성)를 어떻게 할지만 결정하면 됩니다. 복잡한 투자 전략을 케이스별로 구별하지 않고 Strategy 패턴을 이용하여 구현했기 때문에 실제 투자 전략이라면 이익과 손해를 계산하여 런타임에 전략을 교체할 것입니다.

## 2. State 패턴 & Singleton 패턴

![stateAndSingleton.png](README%20md%206f5078a2a2a0407b96e45c4df5174dea/stateAndSingleton.png)

- 디자인 패턴 설명

금융 서비스에서는 다양한 계좌 상태 혹은 거래 상태가 존재합니다.
**State 패턴은 '상태'를 클래스로 표현하고 클래스를 전환함으로써 '상태 변화'를 나타낼 수 있습니다.**

계좌 상황에 따라 계좌 상태가 교체되었다고 해도 상태는 반드시 단일된 객체이자 정보이어야 합니다. 예를 들면 아주 튼튼한 보안을 가지고 있는 상태는 반드시 하나의 인스턴스이어야 하고 이 객체에 접근해야 합니다. 왜냐하면, 훌륭한 보안성을 갖춘 상태 정보가 새롭게 하나 더 만들어진다면 훌륭한 보안성을 유지하기 위해 객체가 가지고 있는 비용 자체가 많이 듭니다. 또한, 상태 정보 그 자체를 가지고 있는 객체이기 때문에 다른 객체가 하나 더 생긴다면 "상태" 자체를 클래스로 표현한 의미가 옅어질 수 있습니다.

**Singleton 패턴은 이러한 요구 사항을 충족시키며, 하나의 인스턴스만 생성하고 전역적으로 접근할 수 있도록 합니다.**

- 코드 설명

본 코드는 State 패턴, Singleton 패턴, Map 자료 구조를 사용하고 고객 계좌의 잔액에 따라 상태를 구분합니다. 그리고, JAVA GUI를 통해 고객 계좌 상태에 따라 매도, 매매를 추천하고 경고합니다. 주식 거래가 허용되는 시간을 고려하여 또 다시 State 패턴과 Singleton 패턴, Map을 이용하여 주식 거래 장 상태를 구분합니다. 거래가 불가능한 시간에는 주가가 바뀌지 않고 어떠한 거래도 허용하지 않습니다. 거래 허용 시간에 주가는 1초에 한번씩 바뀌며, 주가에 따라 계좌 잔액이 바뀝니다. 고객 신용 등급 상태는 바뀐 계좌 잔액에 따라 상태가 바뀌게 됩니다.

- 디자인 패턴을 사용함에 따른 결과 해석

이러한 방식은 상태에 의존해서 서비스의 처리를 수행하고 있습니다. 이는 서비스를 개발하면서 반드시 나타날 수 밖에 없는 케이스 처리를 객체 지향적으로 처리한다는 것에 의미가 있다고 생각합니다.

if, else 문과 같은 조건문을 사용하게 된다면 각 케이스에 변화가 생기거나, 추가해야 할 경우가 생긴다면 굉장히 복잡하게 될 것입니다. 하지만 상태 자체가 클래스로 표현되고, 각 상태는 singleton 패턴을 사용해서 하나의 인스턴스만 가지게 되기 때문에 복잡한 케이스를 안정적으로 처리할 수 있게 합니다.
저는 단순하게 적은 양의 케이스의 시간과 계좌 상태에만 적용을 하게 되었지만, 각 시간별로 케이스를 다르게 하고 싶거나 복잡하고 다양한 계좌 상태에 행동을 부여하고 싶다면 굉장히 효과적인 디자인 패턴이라고 생각합니다.

## 3. Factory 패턴

![factory.png](README%20md%206f5078a2a2a0407b96e45c4df5174dea/factory.png)

- 디자인 패턴 설명

금융 서비스에서는 여러 종류의 금융 상품을 생성해야 할 때가 있습니다.
**Factory Method 패턴은 객체 생성을 서브 클래스에 위임하여 쉽게 확장 가능한 디자인을 제공합니다.**

- 코드 설명

본 코드는 Factory 패턴을 사용하여 사용자별로 계좌를 만들고 ELS, ELW, DLS 와 같은 파생결합증권을 등록한 후에 사용하는 과정을 설명하고 있습니다.

- 디자인 패턴을 사용함에 따른 결과 해석

이러한 방식의 핵심은 상위 클래스에서 처리의 뼈대를 만들고, 하위 클래스에서 구체적인 살을 붙인다는 것입니다. 인스턴스 생성 방법은 모두 상위 클래스에서 결정하지만, 구체적인 부분(심지어 이름까지도) 하위 클래스가 붙입니다.

이러한 패턴이 얻어낼 수 있는 효과는 인스턴스 생성을 위한 프레임워크와 실제 인스턴스를 생성하는 클래스를 나누어 생각할 수 있다는 것입니다.

예를 들어 같은 프레임워크를 사용하여 전혀 다른 증권 상품을 만든다고 생각해보면, framework 패키지를 import 하는 별개의 상품 패키지를 만들게 될 것 입니다.  

만약 Factory 패턴을 사용하지 않았다면, framework  패키지를 수정해야 할 것입니다. 하지만, Factory 패턴을 적절히 사용했기 때문에 framework 패키지 안에는 파생결합증권 패키지를 import 하지 않았고, Product 와 Factory 클래스에는 파생결합증권과 같은 구체적인 클래스 이름이 전혀 없습니다. 즉, 이는 framework 패키지는 제가 개발했던 파생결합증권 패키지에 의존하지 않고 있고, 새로운 상품을 만들 때 framework 패키지를 전혀 수정하지 않아도 된다는 결론이 도출됩니다.